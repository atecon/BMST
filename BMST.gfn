<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="BMST" ID="1478267657" minver="2015a">
<author email="artur.tarassow@gmail.com">Artur Tarassow</author>
<version>1.0</version>
<date>2016-11-04</date>
<description>Logit + Probit model specifcation tests package</description>
<tags>C25 C52</tags>
<help>
***	Binary Model Specification Test PACKAGE ***

This code comprises 3 specification tests for binary Logit models
and 2 specification tests for binary Probit models.

*** NOTE: This package replaces the packages ***

	(A) LOGIT_HETERO.gfn (vers. 0.2)
			and
	(B) logit_the burr (vers. 0.5)

*** which will not be further developed. ***

--------------------------
# Details of the functions
--------------------------
1) Logit_burr(): LM test of the null that the distribution
				is Logistic against the alternative
				that is is Burr Type 2 (and hence skewed - to
				the left or to the right)
	References:
	* J. M. Thomas (1993), &quot;On Testing the Logistic Assumption in Binary
	Dependent Variable Models&quot; Empirical Economics, 1993, 18:381-392
	* D. J. Poirier (1980), &quot; A Lagrange Multiplier Test for Skewness in Binary
	Logit Models. Economics Letters&quot;, 5, 141-143

2) Logit_hom(): In the LM test for homoskedasticity, the form
				of the skedastic function is taken to be
				exp(2Ztγ) where Zt is the vector giving the tth
				observation on the r variables that are believed
				to give rise to the heteroskedasticity.

3) Logit_reset(): The LM test for functional form are similar
				to the familiar &quot;RESET test&quot; for the standard
				linear OLS model.

4) Probit_hom(): In the LM test for homoskedasticity, the form
				of the skedastic function is taken to be
				exp(2Ztγ) where Zt is the vector giving the tth
				observation on the r variables that are believed
				to give rise to the heteroskedasticity.

5) Probit_reset(): The LM test for functional form are similar
				to the familiar &quot;RESET test&quot; for the standard
				linear OLS model.

 	* Davidson, R. &amp; J. G. MacKinnon (1984), &quot;Convenient Specification
	Tests for Logit and Probit Models&quot;, Journal of Econometrics 25, 241 262.
	* Davidson, R. &amp; J. G. MacKinnon (2004), Econometric Theory and Methods,
	Oxford University Press, Oxford.

For more information see Dave Giles,
  ULR: http://web.uvic.ca/~dgiles/downloads/binary_choice/index.html

Dave Giles' original Eviews codes were translated by
Artur Tarassow
Email:
artur.tarassow@wiso.uni-hamburg.de
or
artur.tarassow@gmail.com

---------------------------------------------------------------------------
CHANGELOG:
	Vers. 0.5:
	- Joint package of separate functions
---------------------------------------------------------------------------

-----------------------
* FUNCTION DESCRIPTION
-----------------------

*** A) setupBMST()
	INPUT:
			y		- series, provide a series of the endogeneous
			xx		- list, of regressors (incl. intercept)
			yhat		- series, fitted values
			betahat 	- matrix, coefficient vector
			Type		- int, Model: 1=LOGIT, 2=LOGIT
	        	verbose 	- int, (optional) Print details: 0=NO, 1=YES
 	OUTPUT:
	 		b		- bundle, stores relevant information in a bundle

*** B) Logit_burr(&amp;b)
	INPUT:
			b		- bundle, provided bundle from setupBMST()
 	Information stored in bundle 'b':
			Log_burr_pval 	- scalar, pvalue
			Log_burr_test	- scalar, test stat.

*** C) Logit_hom(&amp;b)
	INPUT:
			b		- bundle, provided bundle from setupBMST()
 	Information stored in bundle 'b':
			Log_hom_pval 	- scalar, pvalue
			Log_hom_test	- scalar, test stat.

*** D) Logit_reset(&amp;b)
	INPUT:
			b		- bundle, provided bundle from setupBMST()
 	Information stored in bundle 'b':
			Log_reset_pval 	- scalar, pvalue
			Log_reset_test	- scalar, test stat.

*** E) Probit_hom(&amp;b)
	INPUT:
			b		- bundle, provided bundle from setupBMST()
 	Information stored in bundle 'b':
			Prob_hom_pval 	- scalar, pvalue
			Prob_hom_test	- scalar, test stat.

*** F) Probit_reset(&amp;b)
	INPUT:
			b		- bundle, provided bundle from setupBMST()
 	Information stored in bundle 'b':
			Prob_reset_pval - scalar, pvalue
			Prob_reset_test	- scalar, test stat.

-----------------------------------
QUICK INTRODUCTION FOR USING THE BMST PACKAGE
-----------------------------------
  (1) The user must alway call the setupBMST() function first. The output will be
	a bundle (e.g. 'b') containing all necessary information for the following tests.
 (2) Next, the actual function conducting one of the various tests is called in
	pointer form, e.g. by 'Probit_reset(&amp;b)'.
 (3) The user can access the produced information (pvalue, test statistics etc.)
	via the bundle. For instance by 'scalar pvalue = b.Prob_reset_pval'. See
	&quot;Example 1&quot; for an illustration.
</help>
<gretl-function name="setupBMST" type="bundle">
 <params count="6">
  <param name="y" type="series">
<description>Endogenous</description>
  </param>
  <param name="xx" type="list">
<description>List of regressors (incl. intercept), $xlist</description>
  </param>
  <param name="yhat" type="series">
<description>Fitted values, {$yhat}</description>
  </param>
  <param name="betahat" type="matrix">
<description>Estimated coefficient vector, $coeff</description>
  </param>
  <param name="Type" type="int" min="1" max="2">
<description>1=Logit, 2=Probit</description>
  </param>
  <param name="verbose" type="int" min="0" max="1" default="1">
<description>(optional) Print details: 0=NO, 1=YES</description>
  </param>
 </params>
<code>bundle b
matrix betahat = vec(betahat)
if nelem(xx)!=rows(betahat)
  printf &quot;Note: The no. of elements in list xx doesn't equal the no.\n           of rows in vector betahat. Check this please.&quot;
  stop
endif
# Some basic information shared by the other functions
matrix b.mx = xx
matrix b.my = { y }
scalar b.ny = rows(b.my)
matrix b.bf = {yhat}
matrix b.betahat = betahat
matrix b.xbeta = {lincomb(xx,betahat)}
scalar r = nelem(xx)
if inlist(xx,0)
  r=r-1
endif
scalar b.r=r
scalar b.n = rows(b.my)
b.Type = Type
b.verbose = verbose
return b
</code>
</gretl-function>
<gretl-function name="Logit_burr" type="void">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>matrix my = b.my
list xx = b.mx
matrix dee = 1 .+ exp(b.xbeta)
matrix bf = 1/dee
matrix sf = (dee-1)./dee.^2
matrix sr = my.*sqrt(bf./(1.-bf)) - (1.-my).*sqrt((1.-bf)./bf)
matrix scalefac = sf./sqrt((1.-bf).*bf)
matrix r1m = {xx}.*scalefac
matrix r2m = log(dee).*sqrt(bf./(1-bf))
matrix X = r1m ~ r2m
matrix U = zeros(rows(sr),1)
matrix bhat = mols(sr,X,&amp;U)
matrix fitted = sr .- U
scalar lm = sum(fitted.^2)
scalar p_val = pvalue(c,1,lm)
if b.verbose==1
  printf &quot;-------------------------------------------------------\n&quot;
  printf &quot;*** Logit model LM Test of Logistic Against Burr Type II ***\n&quot;
  printf &quot;H0: \t Logistic distribution\n&quot;
  printf &quot;H1: \t Burr (skewed) distribution\n&quot;
  printf &quot;N = %d\n&quot;, rows(my)
  printf &quot;LM-BURR = %2.4f (prob= %.3f)&quot;, lm, p_val
  printf &quot;\n-------------------------------------------------------\n&quot;
endif
b.Log_burr_pval = p_val
b.Log_burr_test = lm
</code>
</gretl-function>
<gretl-function name="Logit_hom" type="void">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>#Fit the auxiliary regression for the homoskedasticity test:
if b.Type==2
  printf &quot;The function Logit_hom() only works for Logit models, but \n           you estimated a Probit model.\n&quot;
  stop
endif
#preplogit(&amp;b)
prepare(&amp;b)
list xx = b.mx
matrix mx = {xx}
list zz = xx - const
matrix r2m = {zz}.*b.scalefacz
matrix X = b.r1m ~ r2m
matrix U = zeros(rows(b.lhs),1)
mols(b.lhs,X,&amp;U)
matrix fitted = b.lhs .- U
matrix f2=fitted.^2
scalar lm_het=sum(f2)
# The homoskedasticity  test statistic is asymptotically Chi Square with &quot;r&quot; degrees of freedom, under the null of  homoskedasticity, where &quot;r&quot; is the number of variables involved in the (alternative) heteroskedasticity. So calculate the (asymptotic)  p-value:
scalar het_p_val = (1-cdf(c,b.r,lm_het))
if b.verbose==1
  printf &quot;-------------------------------------------------------\n&quot;
  printf &quot;*** Logit model LM test for homoskedasticity ***\n&quot;
  printf &quot;H0: \t Residuals are homoskedastic\n&quot;
  printf &quot;H1: \t Residuals are heteroskedastic\n&quot;
  printf &quot;N = %d\n&quot;, b.n
  printf &quot;LM-HOM = %2.3f (p=%.3f)\n&quot;, lm_het, het_p_val
  printf &quot;-------------------------------------------------------\n&quot;
endif
b.Log_hom_test = lm_het
b.Log_hom_pval = het_p_val
</code>
</gretl-function>
<gretl-function name="Logit_reset" type="void">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code># Fit the auxiliary regression for the functional form (RESET) test:
if b.Type==2
  printf &quot;The function Logit_reset() only works for Logit models, but \n           you estimated a Probit model.\n&quot;
  printf &quot;Use the function Probit_reset() instead.\n&quot;
  stop
endif
prepare(&amp;b)
#preplogit(&amp;b)
matrix r3=b.scalefacx.*(b.xbeta).^2
matrix rhs = r3 ~ b.r1m
# The coeffcient to be tested is that of the first regerssor - see the ordering of the above group
matrix V = zeros(rows(b.lhs),cols(rhs))
matrix U = zeros(rows(b.lhs),1)
matrix bhat = mols(b.lhs,rhs,&amp;U,&amp;V)
matrix stderr = sqrt(diag(V))	#standard errors
matrix tstat = bhat./stderr
scalar lm_reset=tstat[1]
# The functional form  test statistic is asymptotically standard normal. So calculate the (asymptotic)  p-value:
scalar reset_p_val=2*(1-cnorm(abs(lm_reset)))
if b.verbose==1
  printf &quot;-------------------------------------------------------\n&quot;
  printf &quot;*** Logit model LM test for correct functional form ***\n&quot;
  printf &quot;H0: \t Functional form is correct\n&quot;
  printf &quot;H1: \t Functional form is not correct\n&quot;
  printf &quot;N = %d\n&quot;, b.n
  printf &quot;LM-RESET = %2.3f (p=%.3f)\n&quot;, lm_reset, reset_p_val
  printf &quot;-------------------------------------------------------\n&quot;
endif
b.Log_reset_test = lm_reset
b.Log_reset_pval = reset_p_val
</code>
</gretl-function>
<gretl-function name="Probit_hom" type="void">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>#Fit the auxiliary regression for the homoskedasticity test:
if b.Type==1
  printf &quot;The function Probit_hom() only works for Probit models, but \n           you estimated a Probit model.\n&quot;
  printf &quot;Use the function Logit_hom() instead.\n&quot;
  stop
endif
prepare(&amp;b)
#prepprobit(&amp;b)
matrix r1 = b.r1m
matrix r2 = b.r2m
matrix rhs = b.r1m ~ b.r2m
# Fit the auxiliary regression for the homoskedasticity test:
matrix U = zeros(rows(b.lhs),1)
matrix bhat = mols(b.lhs,rhs,&amp;U)
matrix fitted = b.lhs .- U
scalar lm_het=sum(fitted.^2)
# The homoskedasticity test statistic is asymptotically Chi Square with
# &quot;r&quot; degrees of freedom, under the null of  homoskedasticity, where &quot;r&quot;
# is the number of variables involved in the (alternative) heteroskedasticity.
# So calculate the (asymptotic)  p-value:
scalar het_p_val = (1-cdf(c,b.r,lm_het))	#pvalue(c,lm_het,r)
if b.verbose==1
  printf &quot;-------------------------------------------------------\n&quot;
  printf &quot;*** Probit model LM test for homoskedasticity ***\n&quot;
  printf &quot;H0: \t Residuals are homoskedastic\n&quot;
  printf &quot;H1: \t Residuals are heteroskedastic\n&quot;
  printf &quot;N = %d\n&quot;, b.n
  printf &quot;LM-HOM = %2.3f (p=%.3f)\n&quot;, lm_het, het_p_val
  printf &quot;-------------------------------------------------------\n&quot;
endif
b.Prob_hom_test = lm_het
b.Prob_hom_pval = het_p_val
</code>
</gretl-function>
<gretl-function name="Probit_reset" type="void">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code># Fit the auxiliary regression for the functional form (RESET) test:
if b.Type==1
  printf &quot;The function Probit_reset() only works for Probit models, but \n           you estimated a Probit model.\n&quot;
  printf &quot;Use the function Logit_reset() instead.\n&quot;
  stop
endif
prepare(&amp;b)
#prepprobit(&amp;b)
matrix r3=b.scalefacx.*(b.xbeta).^2
matrix rhs = r3 ~ b.r1m
# The coeffcient to be tested is that of the first regerssor - see the ordering of the above group
matrix V = zeros(rows(b.lhs),cols(rhs))
matrix U = zeros(rows(b.lhs),1)
matrix bhat = mols(b.lhs,rhs,&amp;U,&amp;V)
matrix fitted = b.lhs .- U
matrix stderr = sqrt(diag(V))
matrix tstat = bhat./stderr
scalar lm_reset=tstat[1]
#The functional form  test statistic is asymptotically standard normal.
# So calculate the (asymptotic) p-value
scalar reset_p_val = 2*(1-cnorm(abs(lm_reset)))
if b.verbose==1
  printf &quot;-------------------------------------------------------\n&quot;
  printf &quot;*** Probit model LM test for correct functional form ***\n&quot;
  printf &quot;H0: \t Functional form is correct\n&quot;
  printf &quot;H1: \t Functional form is not correct\n&quot;
  printf &quot;N = %d\n&quot;, b.n
  printf &quot;LM-RESET = %2.3f (p=%.3f)\n&quot;, lm_reset, reset_p_val
  printf &quot;-------------------------------------------------------\n&quot;
endif
b.Prob_reset_test = lm_reset
b.Prob_reset_pval = reset_p_val
</code>
</gretl-function>
<gretl-function name="prepare" type="scalar" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code># Some joint preparations for tests on
# homoskedasticty and functional form
# Jack's clever idea
scalar err = 0
scalar type = b.Type
if (type &lt; 1) || (type &gt; 2)
  printf &quot;What? type = %d\n&quot;, type
  err = 1
  return err
endif
matrix my = b.my
series y = my
list xx = b.mx
matrix bf = (type == 1) ? logistic(b.xbeta) : cnorm(b.xbeta)
matrix sf = (type == 1) ? bf .* (1-bf) : dnorm(b.xbeta)
matrix s = sqrt(b.bf.*(1.-b.bf))
b.lhs = (my-b.bf)./ s
b.scalefacx = sf./ s
b.scalefacz = -b.xbeta.*b.scalefacx
b.r1m={xx}.*b.scalefacx
if type == 2 # Probit
  list zz = xx - const
  b.r2m={zz}.*b.scalefacz
endif
return err
</code>
</gretl-function>
<sample-script>
#----------
# Example 1
#----------
set echo off
set messages off
open greene19_1.gdt
include BMST.gfn

# Logit example
type = 1
logit GRADE 0 GPA TUCE PSI
# setupBMST() must always be called 1st:
bundle b = setupBMST(GRADE, $xlist, $yhat, $coeff, type, 1)
Logit_burr(&amp;b)		# Next, call the test of interest
print b				# Print information stored in the bundle
scalar burr_pval = b.Log_burr_pval	# Store p-value of Logistic Against Burr Type II test
print burr_pval
# Call other tests
Logit_reset(&amp;b)
Logit_hom(&amp;b)

# Probit example
type = 2
probit GRADE 0 GPA TUCE PSI
bundle c = setupBMST(GRADE, $xlist, $yhat, $coeff, type, 1)
Probit_reset(&amp;c)
Probit_hom(&amp;c)


/* Activate if needed
#--------------------------------------------------------
# Example 2: Replicate Dave Gile's PROBIT_HETERO program
#--------------------------------------------------------
open http://web.uvic.ca/~dgiles/downloads/binary_choice/Logistic_Burr.wf1 --quiet
include BMST.gfn
type = 2
probit Y 0 X1 X2
bundle b = setupBMST(Y, $xlist, $yhat, $coeff, type, 1)
Probit_reset(&amp;b)
Probit_hom(&amp;b)
#----------------------------------------
# Replicate Dave Gile's LOGIT_HETERO and
# LOGIT_BURR programs
#-----------------------------------------
type = 1 
logit Y const X1 X2
bundle b = setupBMST(Y,$xlist, $yhat, $coeff,type, 1)
Logit_burr(&amp;b)
Logit_reset(&amp;b)
Logit_hom(&amp;b)

*/
</sample-script>
</gretl-function-package>
</gretl-functions>

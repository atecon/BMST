/*
   ##############################################################################
   ***	Binary Model Specifcation Test PACKAGE ***

   This code comprises 3 specification tests for binary Logit models
   and 2 specification tests for binary Probit models.

   1) Logit_burr(): LM test of the null that the distribution
   #				is Logistic against the alternative
   #				that is is Burr Type 2 (and hence skewed - to
   #				the left or to the right)
   #	References:
   #	* J. M. Thomas (1993), "On Testing the Logistic Assumption in Binary
   #	Dependent Variable Models" Empirical Economics, 1993, 18:381-392
   #	* D. J. Poirier (1980), " A Lagrange Multiplier Test for Skewness in Binary
   #	Logit Models. Economics Letters", 5, 141-143

   2) Logit_hom(): In the LM tests for homoskedasticity, the form
   #				of the skedastic function is taken to be
   #				exp(2Ztγ) where Zt is the vector giving the tth
   #				observation on the r variables that are believed
   #				to give rise to the heteroskedasticity.

   3) Logit_reset(): The LM tests for functional form are similar
   #				to the familiar "RESET test" for the standard
   #				linear OLS model.

   4) Probit_hom(): In the LM tests for homoskedasticity, the form
   #				of the skedastic function is taken to be
   #				exp(2Ztγ) where Zt is the vector giving the tth
   #				observation on the r variables that are believed
   #				to give rise to the heteroskedasticity.

   5) Probit_reset(): The LM tests for functional form are similar
   #				to the familiar "RESET test" for the standard
   #				linear OLS model.

   # 	* Davidson, R. & J. G. MacKinnon (1984), "Convenient Specification
   #	Tests for Logit and Probit Models", Journal of Econometrics 25, 241 262.
   #	* Davidson, R. & J. G. MacKinnon (2004), Econometric Theory and Methods,
   #	Oxford University Press, Oxford.

   For more information see Dave Giles,
   ULR: http://web.uvic.ca/~dgiles/downloads/binary_choice/index.html

   Dave Giles' original Eviews codes were translated by
   Artur Tarassow
   Email:
   artur.tarassow@wiso.uni-hamburg.de
   or
   artur.tarassow@gmail.com

   ---------------------------------------------------------------------------
   CHANGELOG:
   #	Vers. 0.5:
   #	- Joint package of separate functions
   #	- NOTE: This package replaces the LOGIT_HETERO.gfn package (vers. 0.2)
   #		which will not further developed!
   ---------------------------------------------------------------------------

   -----------------------
   * FUNCTION DESCRIPTION
   -----------------------

   *** A) setupBMST()
   #	INPUT:
   #			y		- series, provide a series of the endogeneous
   #			xx		- list, of regressors (incl. intercept)
   #			yhat	- series, fitted values
   #			betahat - matrix, coefficient vector
   #			Type	- int, Model: 1=LOGIT, 2=LOGIT
   #	        verbose - int, (optional) Print details: 0=NO, 1=YES
   # 	OUTPUT:
   #	 		b		- bundle, output of relevant information in a bundle

   *** B) Logit_burr()
   #	INPUT:
   #			b		- bundle, provide bundle from setupBMST()
   # 	OUTPUT:
   #			Log_burr_pval - scalar, pvalue
   #			Log_burr_test- scalar, test stat.

   *** C) Logit_hom()
   #	INPUT:
   #			b		- bundle, provide bundle from setupBMST()
   # 	OUTPUT:
   #			Log_hom_pval - scalar, pvalue
   #			Log_hom_test- scalar, test stat.

   *** D) Logit_reset()
   #	INPUT:
   #			b		- bundle, provide bundle from setupBMST()
   # 	OUTPUT:
   #			Log_reset_pval - scalar, pvalue
   #			Log_reset_test- scalar, test stat.

   *** E) Probit_hom()
   #	INPUT:
   #			b		- bundle, provide bundle from setupBMST()
   # 	OUTPUT:
   #			Prob_hom_pval - scalar, pvalue
   #			Prob_hom_test- scalar, test stat.

   *** F) Probit_reset()
   #	INPUT:
   #			b		- bundle, provide bundle from setupBMST()
   # 	OUTPUT:
   #			Prob_reset_pval - scalar, pvalue
   #			Prob_reset_test- scalar, test stat.
   ##############################################################################
*/
function scalar prepare (bundle *b)
    # Some joint preparations for tests on
    # homoskedasticty and functional form

    scalar err = 0

    scalar type = b.Type

    if (type < 1) || (type > 2)
        printf "What? type = %d\n", type
        err = 1
        return err
    endif

    matrix my = b.my
    series y = my
    list xx = b.mx        

    matrix bf = (type == 1) ? logistic(b.xbeta) : cnorm(b.xbeta)
    matrix sf = (type == 1) ? bf .* (1-bf) : dnorm(b.xbeta)
    matrix s = sqrt(b.bf.*(1.-b.bf))
    b.lhs = (my-b.bf)./ s
    b.scalefacx = sf./ s
    b.scalefacz = -b.xbeta.*b.scalefacx
    b.r1m={xx}.*b.scalefacx

    if type == 2 # Probit
        list zz = xx - const        
        b.r2m={zz}.*b.scalefacz
    endif

    return err

end function 


function bundle setupBMST (series y "Endogenous",
                           list xx "List of regressors (incl.intercept), $xlist",
                           series yhat "Fitted values, {$yhat}",
                           matrix betahat "Estimated coefficient vector, $coeff",
                           int Type[1:2:] "1=Logit, 2=Probit",
                           int verbose[0:1:1] "(optional) Print details: 0=NO, 1=YES")
    bundle b
    matrix betahat = vec(betahat)
    if nelem(xx)!=rows(betahat)
        printf "Note: The no. of elements in list xx doesn't equal the no.\n           of rows in vector betahat. Check this please."
        stop
    endif

    # Some basic information shared by the other functions
    matrix b.mx = xx
    matrix b.my = { y }
    scalar b.ny = rows(b.my)
    matrix b.bf = {yhat}
    matrix b.betahat = betahat
    matrix b.xbeta = {lincomb(xx,betahat)}
    scalar r = nelem(xx)
    if inlist(xx,0)
        r=r-1
    endif
    scalar b.r=r
    scalar b.n = rows(b.my)
    b.Type = Type
    b.verbose = verbose
    return b
end function

function void Logit_burr (bundle *b)
    matrix my = b.my
    list xx = b.mx
    matrix dee = 1 .+ exp(b.xbeta)
    matrix bf = 1/dee
    matrix sf = (dee-1)./dee.^2
    matrix sr = my.*sqrt(bf./(1.-bf)) - (1.-my).*sqrt((1.-bf)./bf)
    matrix scalefac = sf./sqrt((1.-bf).*bf)
    matrix r1m = {xx}.*scalefac
    matrix r2m = log(dee).*sqrt(bf./(1-bf))
    matrix X = r1m ~ r2m
    matrix U = zeros(rows(sr),1)
    matrix bhat = mols(sr,X,&U)
    matrix fitted = sr .- U
    scalar lm = sum(fitted.^2)
    scalar p_val = pvalue(c,1,lm)
    if b.verbose==1
        printf "-------------------------------------------------------\n"
        printf "*** Logit model LM Test of Logistic Against Burr Type II ***\n"
        printf "H0: \t Logistic distribution\n"
        printf "H1: \t Burr (skewed) distribution\n"
        printf "N = %d\n", rows(my)
        printf "LM-BURR = %2.4f (prob= %.3f)", lm, p_val
        printf "\n-------------------------------------------------------\n"
    endif
    b.Log_burr_pval = p_val
    b.Log_burr_test = lm
end function

function void Logit_hom (bundle *b)
    #Fit the auxiliary regression for the homoskedasticity test:
    if b.Type==2
        printf "The function Logit_hom() only works for Logit models, but \n           you estimated a Probit model.\n"
        stop
    endif
    #preplogit(&b)
    prepare(&b)
    list xx = b.mx
    matrix mx = {xx}
    list zz = xx - const
    matrix r2m = {zz}.*b.scalefacz
    matrix X = b.r1m ~ r2m
    matrix U = zeros(rows(b.lhs),1)
    mols(b.lhs,X,&U)
    matrix fitted = b.lhs .- U
    matrix f2=fitted.^2
    scalar lm_het=sum(f2)
    # The homoskedasticity  test statistic is asymptotically Chi Square with "r" degrees of freedom, under the null of  homoskedasticity, where "r" is the number of variables involved in the (alternative) heteroskedasticity. So calculate the (asymptotic)  p-value:
    scalar het_p_val = (1-cdf(c,b.r,lm_het))
    if b.verbose==1
        printf "-------------------------------------------------------\n"
        printf "*** Logit model LM test for homoskedasticity ***\n"
        printf "H0: \t Residuals are homoskedastic\n"
        printf "H1: \t Residuals are heteroskedastic\n"
        printf "N = %d\n", b.n
        printf "LM-HOM = %2.3f (p=%.3f)\n", lm_het, het_p_val
        printf "-------------------------------------------------------\n"
    endif
    b.Log_hom_test = lm_het
    b.Log_hom_pval = het_p_val
end function

function void Logit_reset (bundle *b)
    # Fit the auxiliary regression for the functional form (RESET) test:
    if b.Type==2
        printf "The function Logit_reset() only works for Logit models, but \n           you estimated a Probit model.\n"
        printf "Use the function Probit_reset() instead.\n"
        stop
    endif
    prepare(&b)
    #preplogit(&b)
    matrix r3=b.scalefacx.*(b.xbeta).^2
    matrix rhs = r3 ~ b.r1m
    # The coeffcient to be tested is that of the first regerssor - see the ordering of the above group
    matrix V = zeros(rows(b.lhs),cols(rhs))
    matrix U = zeros(rows(b.lhs),1)
    matrix bhat = mols(b.lhs,rhs,&U,&V)
    matrix stderr = sqrt(diag(V))	#standard errors
    matrix tstat = bhat./stderr
    scalar lm_reset=tstat[1]
    # The functional form  test statistic is asymptotically standard normal. So calculate the (asymptotic)  p-value:
    scalar reset_p_val=2*(1-cnorm(abs(lm_reset)))
    if b.verbose==1
        printf "-------------------------------------------------------\n"
        printf "*** Logit model LM test for correct functional form ***\n"
        printf "H0: \t Functional form is correct\n"
        printf "H1: \t Functional form is not correct\n"
        printf "N = %d\n", b.n
        printf "LM-RESET = %2.3f (p=%.3f)\n", lm_reset, reset_p_val
        printf "-------------------------------------------------------\n"
    endif
    b.Log_reset_test = lm_reset
    b.Log_reset_pval = reset_p_val
end function

function void Probit_hom (bundle *b)
    #Fit the auxiliary regression for the homoskedasticity test:
    if b.Type==1
        printf "The function Probit_hom() only works for Probit models, but \n           you estimated a Probit model.\n"
        printf "Use the function Logit_hom() instead.\n"
        stop
    endif
    prepare(&b)
    #prepprobit(&b)

    matrix r1 = b.r1m
    matrix r2 = b.r2m
    matrix rhs = b.r1m ~ b.r2m
    # Fit the auxiliary regression for the homoskedasticity test:
    matrix U = zeros(rows(b.lhs),1)
    matrix bhat = mols(b.lhs,rhs,&U)
    matrix fitted = b.lhs .- U
    scalar lm_het=sum(fitted.^2)
    # The homoskedasticity test statistic is asymptotically Chi Square with
    # "r" degrees of freedom, under the null of  homoskedasticity, where "r"
    # is the number of variables involved in the (alternative) heteroskedasticity.
    # So calculate the (asymptotic)  p-value:
    scalar het_p_val = (1-cdf(c,b.r,lm_het))	#pvalue(c,lm_het,r)
    if b.verbose==1
        printf "-------------------------------------------------------\n"
        printf "*** Probit model LM test for homoskedasticity ***\n"
        printf "H0: \t Residuals are homoskedastic\n"
        printf "H1: \t Residuals are heteroskedastic\n"
        printf "N = %d\n", b.n
        printf "LM-HOM = %2.3f (p=%.3f)\n", lm_het, het_p_val
        printf "-------------------------------------------------------\n"
    endif
    b.Prob_hom_test = lm_het
    b.Prob_hom_pval = het_p_val
end function

function void Probit_reset (bundle *b)
    # Fit the auxiliary regression for the functional form (RESET) test:
    if b.Type==1
        printf "The function Probit_reset() only works for Probit models, but \n           you estimated a Probit model.\n"
        printf "Use the function Logit_reset() instead.\n"
        stop
    endif
    prepare(&b)
    #prepprobit(&b)

    matrix r3=b.scalefacx.*(b.xbeta).^2
    matrix rhs = r3 ~ b.r1m
    # The coeffcient to be tested is that of the first regerssor - see the ordering of the above group
    matrix V = zeros(rows(b.lhs),cols(rhs))
    matrix U = zeros(rows(b.lhs),1)
    matrix bhat = mols(b.lhs,rhs,&U,&V)
    matrix fitted = b.lhs .- U
    matrix stderr = sqrt(diag(V))
    matrix tstat = bhat./stderr
    scalar lm_reset=tstat[1]
    #The functional form  test statistic is asymptotically standard normal.
    # So calculate the (asymptotic) p-value
    scalar reset_p_val = 2*(1-cnorm(abs(lm_reset)))
    if b.verbose==1
        printf "-------------------------------------------------------\n"
        printf "*** Probit model LM test for correct functional form ***\n"
        printf "H0: \t Functional form is correct\n"
        printf "H1: \t Functional form is not correct\n"
        printf "N = %d\n", b.n
        printf "LM-RESET = %2.3f (p=%.3f)\n", lm_reset, reset_p_val
        printf "-------------------------------------------------------\n"
    endif
    b.Prob_reset_test = lm_reset
    b.Prob_reset_pval = reset_p_val
end function



# sample function call
#----------
# Example 1
#----------
open greene19_1.gdt
include BMST.gfn

# Logit example
type = 1
logit GRADE 0 GPA TUCE PSI
bundle b = setupBMST(GRADE, $xlist, $yhat, $coeff, type, 1)
Logit_burr(&b)
Logit_reset(&b)
Logit_hom(&b)

# Probit example
type = 2
probit GRADE 0 GPA TUCE PSI
bundle b = setupBMST(GRADE, $xlist, $yhat, $coeff, type, 1)
Probit_reset(&b)
Probit_hom(&b)


#--------------------------------------------------------
# Example 2: Replicate Dave Gile's PROBIT_HETERO program
#--------------------------------------------------------
open http://web.uvic.ca/~dgiles/downloads/binary_choice/Logistic_Burr.wf1 --quiet
include BMST.gfn
type = 2
probit Y 0 X1 X2
bundle b = setupBMST(Y, $xlist, $yhat, $coeff, type, 1)
Probit_reset(&b)
Probit_hom(&b)
#----------------------------------------
# Replicate Dave Gile's LOGIT_HETERO and
# LOGIT_BURR programs
#-----------------------------------------
type = 1 
logit Y const X1 X2
bundle b = setupBMST(Y,$xlist, $yhat, $coeff,type, 1)
Logit_burr(&b)
Logit_reset(&b)
Logit_hom(&b)
